name: inbox-bot (monthly)

on:
  workflow_dispatch:
    inputs:
      monthly_stage:
        description: "Which stage to run (00/10/20/30/40)."
        required: true
        default: "00"
        type: choice
        options:
          - "00"
          - "10"
          - "20"
          - "30"
          - "40"
  # 必要なら定期実行（例：22分おき）
  # schedule:
  #   - cron: "*/22 * * * *"

concurrency:
  group: inbox-bot-monthly
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ★ ここが今回の本丸：openai を含めて依存を入れる
      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          if [ -f requirements_monthly_additions.txt ]; then
            pip install -r requirements_monthly_additions.txt
          fi

      # ---- Sanity check: show only lengths/hashes (no secret leak) ----
      - name: Sanity check env (no secret leak)
        shell: bash
        env:
          # Repo variables (plain text)
          LOGS_DIR: ${{ vars.LOGS_DIR }}
          STAGE00_IN: ${{ vars.STAGE00_IN }}
          STAGE00_OUT: ${{ vars.STAGE00_OUT }}
          STAGE00_DONE: ${{ vars.STAGE00_DONE }}
          STAGE10_IN: ${{ vars.STAGE10_IN }}
          STAGE10_OUT: ${{ vars.STAGE10_OUT }}
          STAGE10_DONE: ${{ vars.STAGE10_DONE }}
          STAGE20_IN: ${{ vars.STAGE20_IN }}
          STAGE20_OUT: ${{ vars.STAGE20_OUT }}
          STAGE20_DONE: ${{ vars.STAGE20_DONE }}
          STAGE30_IN: ${{ vars.STAGE30_IN }}
          STAGE30_OUT: ${{ vars.STAGE30_OUT }}
          STAGE30_DONE: ${{ vars.STAGE30_DONE }}
          STAGE40_IN: ${{ vars.STAGE40_IN }}
          STAGE40_OUT: ${{ vars.STAGE40_OUT }}
          STAGE40_DONE: ${{ vars.STAGE40_DONE }}
          # Secrets (do NOT print values)
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          STATE_PATH: ${{ secrets.STATE_PATH }}
        run: |
          set -euxo pipefail
          python - <<'PY'
          import os, hashlib

          def short_hash(s: str) -> str:
              return hashlib.sha256(s.encode("utf-8")).hexdigest()[:12]

          keys = [
              "LOGS_DIR","STATE_PATH",
              "STAGE00_IN","STAGE00_OUT","STAGE00_DONE",
              "STAGE10_IN","STAGE10_OUT","STAGE10_DONE",
              "STAGE20_IN","STAGE20_OUT","STAGE20_DONE",
              "STAGE30_IN","STAGE30_OUT","STAGE30_DONE",
              "STAGE40_IN","STAGE40_OUT","STAGE40_DONE",
          ]
          for k in keys:
              v = os.environ.get(k, "") or ""
              print(f"{k}: len={len(v)} sha256_12={short_hash(v) if v else 'EMPTY'} startswith_/={v.startswith('/') if v else False}")

          print("== secrets present? (length only) ==")
          for k in ["OPENAI_API_KEY","DROPBOX_REFRESH_TOKEN","DROPBOX_APP_KEY","DROPBOX_APP_SECRET"]:
              v = os.environ.get(k, "") or ""
              print(f"{k}: len={len(v)}")
          PY

      # ---- Dropbox pre-run snapshot (stage-aware) ----
      - name: Dropbox snapshot BEFORE run (IN/OUT/DONE + state + latest log folder)
        shell: bash
        env:
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          STATE_PATH: ${{ secrets.STATE_PATH }}
          LOGS_DIR: ${{ vars.LOGS_DIR }}
          STAGE00_IN: ${{ vars.STAGE00_IN }}
          STAGE00_OUT: ${{ vars.STAGE00_OUT }}
          STAGE00_DONE: ${{ vars.STAGE00_DONE }}
          STAGE10_IN: ${{ vars.STAGE10_IN }}
          STAGE10_OUT: ${{ vars.STAGE10_OUT }}
          STAGE10_DONE: ${{ vars.STAGE10_DONE }}
          STAGE20_IN: ${{ vars.STAGE20_IN }}
          STAGE20_OUT: ${{ vars.STAGE20_OUT }}
          STAGE20_DONE: ${{ vars.STAGE20_DONE }}
          STAGE30_IN: ${{ vars.STAGE30_IN }}
          STAGE30_OUT: ${{ vars.STAGE30_OUT }}
          STAGE30_DONE: ${{ vars.STAGE30_DONE }}
          STAGE40_IN: ${{ vars.STAGE40_IN }}
          STAGE40_OUT: ${{ vars.STAGE40_OUT }}
          STAGE40_DONE: ${{ vars.STAGE40_DONE }}
          MONTHLY_STAGE: ${{ inputs.monthly_stage }}
        run: |
          set -euxo pipefail
          python - <<'PY'
          import os, json
          import dropbox
          from dropbox.exceptions import ApiError

          tok = os.environ["DROPBOX_REFRESH_TOKEN"]
          app_key = os.environ["DROPBOX_APP_KEY"]
          app_secret = os.environ["DROPBOX_APP_SECRET"]
          state_path = os.environ.get("STATE_PATH","") or ""
          logs_dir = os.environ.get("LOGS_DIR","") or ""
          stage = (os.environ.get("MONTHLY_STAGE","00") or "00").strip()

          def pick(stage: str, kind: str) -> str:
              key = f"STAGE{stage}_{kind}"
              return os.environ.get(key, "") or ""

          p_in = pick(stage, "IN")
          p_out = pick(stage, "OUT")
          p_done = pick(stage, "DONE")

          dbx = dropbox.Dropbox(oauth2_refresh_token=tok, app_key=app_key, app_secret=app_secret)

          def list_folder(path: str, limit: int = 200):
              print(f"\n== list_folder: {path!r} ==")
              if not path:
                  print("EMPTY path")
                  return
              try:
                  res = dbx.files_list_folder(path)
              except ApiError as e:
                  print("ERROR list_folder:", e)
                  return
              entries = res.entries
              print("count:", len(entries))
              for e in entries[:limit]:
                  t = type(e).__name__
                  pd = getattr(e, "path_display", "")
                  sz = getattr(e, "size", "")
                  print(t, pd, sz)

          print("== stage ==", stage)
          list_folder(p_in)
          list_folder(p_out)
          list_folder(p_done)

          print(f"\n== state_path check: {state_path!r} ==")
          if not state_path:
              print("STATE_PATH is EMPTY")
          else:
              try:
                  md = dbx.files_get_metadata(state_path)
                  print("state exists:", getattr(md, "path_display",""), "size:", getattr(md, "size",""))
                  _, resp = dbx.files_download(state_path)
                  raw = resp.content
                  print("state download bytes:", len(raw))
                  try:
                      obj = json.loads(raw.decode("utf-8"))
                      if isinstance(obj, dict):
                          print("state json keys:", sorted(list(obj.keys()))[:50])
                      else:
                          print("state json is not dict:", type(obj).__name__)
                  except Exception as e:
                      print("state json parse error:", repr(e))
              except ApiError as e:
                  print("state metadata error:", e)

          print(f"\n== logs_dir overview: {logs_dir!r} ==")
          if logs_dir:
              try:
                  res = dbx.files_list_folder(logs_dir)
                  entries = [e for e in res.entries]
                  folders = [e for e in entries if type(e).__name__ == "FolderMetadata"]
                  print("folders:", len(folders))
                  for e in sorted(folders, key=lambda x: x.name)[-10:]:
                      print("Folder", getattr(e, "path_display",""))
              except ApiError as e:
                  print("logs list error:", e)
          PY

      # ---- Preflight ----
      - name: Preflight (compile + import)
        shell: bash
        run: |
          set -euxo pipefail
          python -V
          python -m compileall -q src
          python -c "import src.monthly_main; print('import ok')"

      # ---- Run with wrapper: never silently swallow exceptions ----
      - name: Run pipeline (wrapper; show SystemExit)
        shell: bash
        env:
          # Secrets
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          STATE_PATH: ${{ secrets.STATE_PATH }}

          # Repo variables
          LOGS_DIR: ${{ vars.LOGS_DIR }}
          STAGE00_IN: ${{ vars.STAGE00_IN }}
          STAGE00_OUT: ${{ vars.STAGE00_OUT }}
          STAGE00_DONE: ${{ vars.STAGE00_DONE }}
          STAGE10_IN: ${{ vars.STAGE10_IN }}
          STAGE10_OUT: ${{ vars.STAGE10_OUT }}
          STAGE10_DONE: ${{ vars.STAGE10_DONE }}
          STAGE20_IN: ${{ vars.STAGE20_IN }}
          STAGE20_OUT: ${{ vars.STAGE20_OUT }}
          STAGE20_DONE: ${{ vars.STAGE20_DONE }}
          STAGE30_IN: ${{ vars.STAGE30_IN }}
          STAGE30_OUT: ${{ vars.STAGE30_OUT }}
          STAGE30_DONE: ${{ vars.STAGE30_DONE }}
          STAGE40_IN: ${{ vars.STAGE40_IN }}
          STAGE40_OUT: ${{ vars.STAGE40_OUT }}
          STAGE40_DONE: ${{ vars.STAGE40_DONE }}

          # Controls
          MONTHLY_STAGE: ${{ inputs.monthly_stage }}
          OPENAI_MODEL: gpt-5-mini
          DEPTH: medium
          OPENAI_TIMEOUT: "120"
          OPENAI_MAX_RETRIES: "2"
          OPENAI_MAX_OUTPUT_TOKENS: "5000"
          MAX_FILES_PER_RUN: "200"
          MAX_INPUT_CHARS: "80000"
          PYTHONUNBUFFERED: "1"
        run: |
          set -euxo pipefail
          python -V
          python - <<'PY'
          import runpy, sys, traceback, time
          print("[wrapper] START src.monthly_main", flush=True)
          t0 = time.time()
          try:
              runpy.run_module("src.monthly_main", run_name="__main__")
              print("[wrapper] module returned normally", flush=True)
          except SystemExit as e:
              print(f"[wrapper] SystemExit: code={e.code!r}", file=sys.stderr, flush=True)
              raise
          except Exception:
              print("[wrapper] Unhandled exception:", file=sys.stderr, flush=True)
              traceback.print_exc()
              sys.exit(1)
          finally:
              dt = time.time() - t0
              print(f"[wrapper] END (elapsed_s={dt:.2f})", flush=True)
          PY

      # ---- Dropbox post-run snapshot + fetch latest log file tail ----
      - name: Dropbox snapshot AFTER run (and tail latest log)
        if: always()
        shell: bash
        env:
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          LOGS_DIR: ${{ vars.LOGS_DIR }}
          MONTHLY_STAGE: ${{ inputs.monthly_stage }}
          STAGE00_IN: ${{ vars.STAGE00_IN }}
          STAGE00_OUT: ${{ vars.STAGE00_OUT }}
          STAGE00_DONE: ${{ vars.STAGE00_DONE }}
          STAGE10_IN: ${{ vars.STAGE10_IN }}
          STAGE10_OUT: ${{ vars.STAGE10_OUT }}
          STAGE10_DONE: ${{ vars.STAGE10_DONE }}
          STAGE20_IN: ${{ vars.STAGE20_IN }}
          STAGE20_OUT: ${{ vars.STAGE20_OUT }}
          STAGE20_DONE: ${{ vars.STAGE20_DONE }}
          STAGE30_IN: ${{ vars.STAGE30_IN }}
          STAGE30_OUT: ${{ vars.STAGE30_OUT }}
          STAGE30_DONE: ${{ vars.STAGE30_DONE }}
          STAGE40_IN: ${{ vars.STAGE40_IN }}
          STAGE40_OUT: ${{ vars.STAGE40_OUT }}
          STAGE40_DONE: ${{ vars.STAGE40_DONE }}
        run: |
          set -euxo pipefail
          python - <<'PY'
          import os
          import dropbox
          from dropbox.exceptions import ApiError

          tok = os.environ["DROPBOX_REFRESH_TOKEN"]
          app_key = os.environ["DROPBOX_APP_KEY"]
          app_secret = os.environ["DROPBOX_APP_SECRET"]
          logs_dir = os.environ.get("LOGS_DIR","") or ""
          stage = (os.environ.get("MONTHLY_STAGE","00") or "00").strip()

          def pick(stage: str, kind: str) -> str:
              key = f"STAGE{stage}_{kind}"
              return os.environ.get(key, "") or ""

          p_in = pick(stage, "IN")
          p_out = pick(stage, "OUT")
          p_done = pick(stage, "DONE")

          dbx = dropbox.Dropbox(oauth2_refresh_token=tok, app_key=app_key, app_secret=app_secret)

          def list_folder(path: str, limit: int = 200):
              print(f"\n== list_folder: {path!r} ==")
              if not path:
                  print("EMPTY path")
                  return
              try:
                  res = dbx.files_list_folder(path)
              except ApiError as e:
                  print("ERROR list_folder:", e)
                  return
              entries = res.entries
              print("count:", len(entries))
              for e in entries[:limit]:
                  t = type(e).__name__
                  pd = getattr(e, "path_display", "")
                  sz = getattr(e, "size", "")
                  print(t, pd, sz)

          print("== stage ==", stage)
          list_folder(p_in)
          list_folder(p_out)
          list_folder(p_done)

          print(f"\n== tail latest log: logs_dir={logs_dir!r} ==")
          if not logs_dir:
              print("LOGS_DIR empty")
              raise SystemExit(0)

          try:
              res = dbx.files_list_folder(logs_dir)
              folders = [e for e in res.entries if type(e).__name__ == "FolderMetadata"]
              if not folders:
                  print("no log folders found")
                  raise SystemExit(0)
              latest_folder = sorted(folders, key=lambda x: x.name)[-1].path_display
              print("latest_folder:", latest_folder)

              res2 = dbx.files_list_folder(latest_folder)
              files = [e for e in res2.entries if type(e).__name__ == "FileMetadata"]
              if not files:
                  print("no log files in latest folder")
                  raise SystemExit(0)
              latest = sorted(files, key=lambda x: x.server_modified)[-1]
              print("latest_file:", latest.path_display, "size:", latest.size)

              _, resp = dbx.files_download(latest.path_display)
              raw = resp.content.decode("utf-8", errors="replace")
              print("\n----- LOG TAIL (last ~3000 chars) -----\n")
              print(raw[-3000:])
              print("\n----- END LOG TAIL -----\n")
          except ApiError as e:
              print("log tail error:", e)
          PY
